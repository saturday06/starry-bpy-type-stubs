from collections.abc import Iterable, Iterator, Sequence
from typing import Optional, Union, overload

# TODO: 引数のIterableは本当はSequenceだったりしないか?

class Matrix:
    def __init__(self, rows: Sequence[Sequence[float]] = ()) -> None: ...
    def copy(self) -> "Matrix": ...
    @classmethod
    def Translation(cls, vector: Iterable[float]) -> "Matrix": ...
    @classmethod
    def Rotation(
        cls, angle: float, size: int, axis: Union[str, "Vector"]
    ) -> "Matrix": ...
    @classmethod
    def Identity(cls, size: int) -> "Matrix": ...
    @classmethod
    def Diagonal(cls, vector: "Vector") -> "Matrix": ...

    # ドキュメントには"fallback"という引数がついているが、それを指定すると
    # フォールバック時にそれが返るらしい。でもそれだと型が合わないので
    # 使わないでほしいという気持ちを込めるため書かない。
    def inverted(self) -> "Matrix": ...
    @overload
    def __matmul__(self, other: "Matrix") -> "Matrix": ...
    @overload
    def __matmul__(self, other: "Vector") -> "Vector": ...
    def to_translation(self) -> "Vector": ...
    def transpose(self) -> None: ...
    def __getitem__(self, index: int) -> "Vector": ...
    def __len__(self) -> int: ...
    def inverted_safe(self) -> "Matrix": ...
    def transposed(self) -> "Matrix": ...
    def decompose(self) -> tuple["Vector", "Quaternion", "Vector"]: ...
    def to_4x4(self) -> "Matrix": ...
    @property
    def translation(self) -> "Vector": ...
    def to_quaternion(self) -> "Quaternion": ...
    def to_scale(self) -> "Vector": ...

class Vector(Sequence[float]):
    x: float
    y: float
    z: float

    def __init__(self, seq: Iterable[Union[int, float]]) -> None: ...
    def copy(self) -> "Vector": ...
    def __truediv__(self, other: float) -> "Vector": ...
    def __setitem__(self, index: int, value: float) -> None: ...
    def __add__(self, other: "Vector") -> "Vector": ...
    def __sub__(self, other: "Vector") -> "Vector": ...
    def __mul__(self, other: float) -> "Vector": ...
    def __matmul__(self, other: Matrix) -> "Vector": ...
    @overload
    def __getitem__(self, index: int) -> float: ...
    @overload
    def __getitem__(self, index: slice) -> tuple[float, ...]: ...
    def __iter__(self) -> Iterator[float]: ...
    @property
    def length(self) -> float: ...
    @property
    def length_squared(self) -> float: ...
    def cross(self, other: "Vector") -> "Vector": ...
    def normalize(self) -> None: ...
    def dot(self, other: "Vector") -> float: ...
    def __neg__(self) -> "Vector": ...
    def __len__(self) -> int: ...
    def normalized(self) -> "Vector": ...
    def negate(self) -> None: ...
    def rotate(self, other: Union["Euler", "Quaternion", Matrix]) -> None: ...

class Quaternion:
    x: float
    y: float
    z: float
    w: float

    @overload
    def __init__(
        self, seq: Union[Vector, Iterable[Union[int, float]]], angle: float
    ) -> None: ...
    @overload
    def __init__(
        self,
        wxyz: Union[Vector, Iterable[Union[int, float]]],
    ) -> None: ...
    @overload
    def __init__(self) -> None: ...
    def copy(self) -> "Quaternion": ...
    def rotate(self, other: Union["Euler", "Quaternion", Matrix]) -> None: ...
    def to_matrix(self) -> "Matrix": ...
    def normalized(self) -> "Quaternion": ...
    @overload
    def __matmul__(self, other: "Quaternion") -> "Quaternion": ...
    @overload
    def __matmul__(self, other: "Vector") -> "Vector": ...
    def __setitem__(self, index: int, value: float) -> None: ...  # ドキュメントには存在しない？
    def to_euler(
        self, order: str = "XYZ", euler_compat: Optional["Euler"] = None
    ) -> "Euler": ...
    def to_axis_angle(self) -> tuple[Vector, float]: ...
    def inverted(self) -> "Quaternion": ...

class Color:
    r: float
    g: float
    b: float

class Euler:
    def __init__(self, angles: Iterable[float], order: str = "XYZ") -> None: ...
    def __setitem__(self, index: int, value: float) -> None: ...  # ドキュメントには存在しない？
    def to_quaternion(self) -> Quaternion: ...
    @overload
    def __getitem__(self, index: int) -> float: ...
    @overload
    def __getitem__(self, index: slice) -> tuple[float, ...]: ...
